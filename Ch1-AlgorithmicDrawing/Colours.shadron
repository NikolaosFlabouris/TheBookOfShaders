// Implementaion of the functions described in
// The Book of Shaders, Chapter: Algorithmic Drawing - Colours.

#include <hsv>
#include <math_constants>

const int WIDTH = 720;
const int HEIGHT = 720;

parameter int Function_Selector = 1 : range(1, 4);
parameter float red = 0.0 : range(0.0, 1.0);
parameter float green = 0.0 : range(0.0, 1.0);
parameter float blue = 0.0 : range(0.0, 1.0);

function vec4 colourPicker()
{
    return vec4(red, green, blue, 1.0);
}

function vec4 colourGradient(vec2 position)
{
    return vec4(mix(red, green/2 + blue/2, position.x), mix(green, blue/2 + red/2, position.x), mix(blue, red/2 + green/2, position.x), 1.0);
}

function vec4 hsvGradient(vec2 position)
{
    return vec4(hsv(position.x, 1.0, position.y), 1.0);
}

function vec4 hsvRadial(vec2 position)
{
    // Use polar coordinates instead of cartesian
    vec2 toCenter = vec2(0.5) - position;
    float angle = atan(toCenter.y, toCenter.x);
    float radius = length(toCenter)*2.0;

    // Map the angle (-PI to PI) to the Hue (from 0 to 1)
    // and the Saturation to the radius
    return vec4(hsv(angle/(2*PI) + 0.5, radius, 1.0), 1.0);
}

glsl vec4 shaderPicker(vec2 position)
{

    switch(Function_Selector)
    {
    case 1:
        return colourPicker();
    case 2:
        return colourGradient(position);
    case 3:
        return hsvGradient(position);
    case 4:
        return hsvRadial(position);
    default:
        break;
    }
}

image myShader = glsl(shaderPicker, WIDTH, HEIGHT);